# Design Pattern
<br/>

## 1. 템플릿 메소드 패턴 (Template Method Pattern)
메소드에서 알고리즘의 골격을 정의한다.<br/>
알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다.<br/>
템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브 클래스에서 특정 단계를 재정의 할 수 있다.<br/>
알고리즘의 틀을 만들기 위한 패턴이다.<br/>
이 패턴에서 틀(템플릿)이란 일련의 단계들로 알고리즘을 정의한 메소드다.<br/>
여러 단계 가운데 하나 이상이 추상 메소드로 정의되며, 그 추상 메소드는 서브클래스에서 구현된다.<br/>
이렇게 하면 서브클래스에서 일부분의 단계를 구현할 수 있도록 하면서도 알고리즘의 구조는 바꾸지 않도록 할 수 있다.<br/>
어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 <br/>
전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용을 바꾸는 패턴.<br/>
즉, 전체적으로는 동일하면서 부분적으로 다른 구문으로 구성된 메소드의 코드 중복을 최소화할 때 유용하다.<br/>
다른 관점에서 보면 동일한 기능을 상위 클래스에서 정의하면서 확장/변화가 필요한 부분만 서브 클래스에서 구현할 수 있도록 한다.<br/>
<br/>
=> templateMethod 패키지 참조.<br/>
https://jusungpark.tistory.com/24 <br/>
<br/><br/>

## 2. 프록시 패턴 (Proxy Pattern)
클라이언트에서 프록시 클래스를 통해 간접적으로 주체 클래스를 사용하는 방식.<br/>
프록시가 대리자로써 일을 처리하고 완료되면 결과를 알려주는 패턴.<br/>
프록시의 의미는 "대리자"라는 의미이다.<br/>
무언가를 대신해서 일을 해주는 사람을 말하는데 프록시패턴(Proxy Pattern)은<br/>
대리자로써 일을 맡기면 그 일을 처리하고 완료되면 결과를 알려주는 패턴이다.<br/>
#### * 프록시 종류
(1) 원격 프록시(원격에서 모니터링 하는 경우.)<br/>
(2) 가상 프록시(이미지를 불러오는 동안 무언가 다른것을 보여주고 싶을 때.)<br/>
(3) 동적 프록시(자바 리플렉션 사용. 프록시 클래스가 실행중에 생성됨. 사용자 권한에 따라 다른 페이지 보여줄 때.)<br/>
(4) 방화벽 프록시(네트워크 자원에 대한 접근을 제어함으로써 객체를 공격자로부터 보호.)<br/>
(5) 스마트 패턴 프록시(주 객체가 참조될 때마다 추가 행동을 제공. 래퍼런스 개수 세기 등.)<br/>
(6) 캐싱 프록시(비용이 많이 드는 작업의 결과를 임시로 저장. 웹 서버 프록시, 컨텐츠 관리 및 퍼블리싱 시스템.)<br/>
(7) 동기화 프록시(여러 스레드에서 주 객체에 접근하는 경우 안전하게 작업을 처리하게 해준다.)<br/>
(8) 복잡도 숨김 프록시(퍼사드 패턴이 단순히 인터페이스만 제공하는 것에 비해 복잡도 숨김 프록시는 접근을 제어한다.)<br/>
(9) 지연 복사 프록시(객체 복사를 제어한다.)<br/>
<br/>
=> proxy 패키지 참조.<br/>
https://plposer.tistory.com/31 <br/>
https://meylady.tistory.com/58 <br/>
<br/><br/>

## 3. 퍼사드 패턴 (Facade Pattern)
인터페이스를 간단하게 바꿈 (for 간편함)<br/>
어떤 서브시스템에 대한 간단한 인터페이스를 제공하기 위한 용도.<br/>
퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다.<br/>
클라이언트와 서브시스템이 서로 긴밀하게 연결되지 않아도 되고 최소 지식 원칙을 준수하는데 도움을 준다.<br/>
* 최소 지식 원칙: 정말 친한 친구하고만 얘기하라.<br/>
<br/>
=> facade 패키지 참조.<br/>
https://jusungpark.tistory.com/23?category=630296 <br/>
<br/><br/>

## 4. 싱글톤 패턴 (Singleton Pattern)
인스턴스를 한번만 생성해서 사용하턴 패턴.<br/>
해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴.<br/>
클래스에서 자신의 단 하나뿐인 인스턴스를 관리하도록 만든다.<br/>
다른 어떤 클래스에서도 자신의 인스턴스를 추가로 만들지 못하도록 해야한다. <br/>
멀티 스레드 환경에서 잘 고려해서 사용해야 한다.<br/>
(동기화 사용 시 속도 저하 -> 부분적으로만 사용, 혹은 클래스 로딩 시 인스턴스 생성.) <br/>
<br/>
=> singleton 패키지 참조.<br/>
https://jusungpark.tistory.com/16?category=630296 <br/>
<br/><br/>

## 5. 전략 패턴 (Strategy Pattern)
실행 중에 알고리즘을 선택할 수 있게 하는 패턴.<br/>
알고리즘군을 정의하고 각각 캡슐화하여 교환해서 사용할 수 있도록 만든다.<br/>
스트래티지 패턴을 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.<br/>
<br/>
=> strategy 패키지 참조.<br/>
https://jusungpark.tistory.com/7?category=630296 <br/>
<br/><br/>

## 6. 팩토리 패턴 (Factory Pattern)
객체를 만들어내는 공장을 만드는 패턴.<br/>
(1) 팩토리 메소드 패턴<br/>
클래스의 인스턴스를 만드는 일을 서브 클래스에게 맡기는 것.<br/>
(2) 추상 팩토리 패턴<br/>
인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고 생성하는 것.<br/>
<br/>
=> factory 패키지 참조.<br/>
factoryMethod 패키지와 재료 팩토리가 추가된 abstractFactory 패키지에서 <br/>
각각 NYPizzaStore 클래스의 createPizza()를 보면 <br/>
팩토리 메소드 패턴과 추상 팩토리 패턴에 대해 참조할 수 있다. <br/>
https://jusungpark.tistory.com/14?category=630296 <br/>
<br/><br/>

## 7. 어댑터 패턴 (Adapter Pattern)
한 인터페이스를 다른 인터페이스로 변환 (for 호환성)<br/>
인터페이스를 변경해서 클라이언트에서 필요로 하는 인터페이스로 적응시키기 위한 용도.<br/>
어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.<br/>
<br/>
=> adapter 패키지 참조.<br/>
https://jusungpark.tistory.com/22?category=630296 <br/>
<br/><br/>

## 8. 데코레이터 패턴 (Decorator Pattern)
인터페이스를 바꾸지 않고 책임(기능)만 추가함. (For 기능 추가)<br/>
객체에 추가적인 요건을 동적으로 첨가한다. <br/>
서브 클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.<br/>
- 데코레이터가 적용된 예: Java I/O <br/>
InputStream이 추상 구성요소이고, 모든 보조 스트림의 조상인 FileInputStream이 추상 데코레이터이다.<br/>
FileInputStream을 상속받아 구현하는 BufferedInputStream 클래스들이 구상 데코레이터이다.<br/>
InputStream을 상속받는 FileInputStream 같은 기반 스트림들은 데코레이터로 포장될 구상 구성요소 역할을 한다. <br/>
<br/>
=> decorator 패키지 참조.<br/>
https://jusungpark.tistory.com/9?category=630296 <br/>
<br/><br/>

## 9. 컴포지트 패턴 (Composite Pattern)
객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있다.<br/>
클라이언트에서 개별 객체와 다른 객체들로 구성된 복합객체(composite)를 똑같은 방법으로 다룰 수 있다.<br/>
식당 메뉴를 예로들어 생각해본다면 중첩되어 있는 메뉴 그룹과 메뉴 항목을 똑같은 구조내에서 처리할 수 있게끔 하는 것이다.<br/>
메뉴와 메뉴항목을 같은 구조에 집어넣어서 부분-전체 계층구조를 생성할 수 있다.<br/>
이런 복합구조를 사용하면 복합객체와 개별객체에 대해 구분없이 똑같은 작업을 적용할 수 있다.<br/>
<br/>
=> composite 패키지 참조.<br/>
https://jusungpark.tistory.com/26?category=630296 <br/>
<br/><br/>

## 10. 이터레이터 패턴 (Iterator Pattern)
컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공한다.<br/>
컬렉션 객체 안에 들어있는 모든 항목에 접근하는 방식이 통일되어 있으면<br/>
어떤 종류의 집합체에 대해서도 사용할 수 있는 다형적인 코드를 만들 수 있다.<br/>
이터레이터 패턴을 사용하면 모든 항목에 일일이 접근하는 작업을 컬렉션 객체가 아닌 반복자 객체에서 맡게 된다.<br/>
이렇게 하면 집합체의 인터페이스 및 구현이 간단해질뿐 아니라<br/>
집합체에서는 반복작업에서 손을 떼고 원래 자신이 할 일(객체 컬렉션 관리)에만 전념할 수 있다.<br/>
<br/>
=> iterator 패키지 참조.<br/>
https://jusungpark.tistory.com/25?category=630296 <br/>
<br/><br/>

## 11. 커맨드 패턴 (Command Pattern)
요구사항을 객체로 캡슐화 할 수 있으며, 매개변수를 써서 여러가지 다른 요구사항을 집어넣을 수 있다.<br/>
또한 요청 내역을 큐에 저장하거나 로그로 기록할 수도 있으며 작업 취소 지원도 가능하다. <br/>
커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구사항을 캡슐화한다.<br/>
이렇게 하기 위해 행동과 리시버를 한 객체에 집어넣고 메소드 하나만 외부에 공개하는 방법을 사용한다.<br/>
<br/>
예) 식당을 예로 들어보자.<br/><br/>
(1) 손님이 웨이터에게 주문을 한다.<br/>
(2) 웨이터가 고객의 주문을 주문서에 적는다.<br/>
(3) 웨이터는 주문서를 주방에 전달하여 주문을 요청한다.<br/>
(4) 요리사는 주문서에 적힌 주문대로 음식을 자신의 노하우로 만든다.<br/>
- 손님 => 클라이언트
- 웨이터 => 인보커 객체
- 주문서 => 커맨드 객체
- 주방장 => 리시버 객체
- 주문을 하는 것 => setCommand()
- 주문을 요청하는 것 => execute()
<br/>
=> command 패키지 참조. <br/>
https://jusungpark.tistory.com/18?category=630296 <br/>
<br/><br/>

## 12. 옵저버 패턴 (Observer Patter)
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 <br/>
자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.<br/>
옵저버 패턴을 구현하는 방법에는 여러가지가 있지만 대부분 상태를 저장하고 있는 주제 인터페이스를 구현한 주제 객체와<br/>
주제 객체에 의존하고 있는 옵저버 인터페이스를 구현한 여러개의 옵저버 객체가 있는 디자인을 바탕으로 한다.<br/>
<br/>
데이터 전달 방식은 2가지가 있다.<br/>
<br/>
(1) 주제 객체에서 옵저버로 데이터를 보내는 방식 (푸시 방식)<br/>
-> observer.push 패키지 참조.<br/>
<br/>
(2) 옵저버에서 주제 객체의 데이터를 가져가는 방식 (풀 방식)<br/>
-> 자바 9부터 deprecated 됨.<br/>
-> 자바 내장 옵저버 사용하는 방식. 푸시 방식, 풀 방식 모두 사용가능. <br/>
<br/>
=> observer 패키지 참조. <br/>
https://jusungpark.tistory.com/8?category=630296 <br/>
<br/><br/>

## 13. 스테이트 패턴 (State Pattern)
일련의 규칙에 따라 객체의 상태(State)를 변화시켜, 객체가 할 수 있는 행위를 바꾸는 패턴.<br/>
=> state 패키지 참조. <br/>
https://victorydntmd.tistory.com/294 <br/>
https://www.journaldev.com/1751/state-design-pattern-java <br/>
<br/><br/>

## 기타 패턴들..
컴파운드 패턴<br/>
브리지 패턴<br/>
빌더 패턴<br/>
역할 사슬 패턴<br/>
플라이웨이트 패턴<br/>
인터프리터 패턴<br/>
미디에이터 패턴<br/>
메멘토 패턴<br/>
프로토타입 패턴<br/>
비지터 패턴<br/>
<br/><br/>

--

#### * 결합도, 응집도
결합도는 낮고, 응집도는 높을수록 좋다.
<br/><br/>